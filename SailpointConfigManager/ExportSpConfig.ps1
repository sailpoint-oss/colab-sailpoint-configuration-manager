#
# To extract configuration using sp-config into a output file
# Generated by: Raghunath Anne
# Generated on: 18/02/2024
#


<#
.SYNOPSIS

Export the configuration from json response to files.

.DESCRIPTION

Export the configuration from json response to files.

.OUTPUTS

No return
#>
function Export-Files($ConfigResponse){
	Write-Debug "Start Extract to files"
	foreach($Object in $ConfigResponse.objects){		
		$Path = $OUTPUT_PATH+"$($Object.self.type)\"		
		if(!(Test-Path $Path)){
			New-Item -ItemType Directory -Path $Path
		}
		Write-Debug "Start Extract to files in folder - $Path"
		#TODO:ADD Alphanumeric regex to fix naming for $fileName
		$fileName="$($Object.self.name).json"		
		$fileName=$fileName.Replace( "\","_");
		$fileName=$fileName.Replace("/","_");
		$fileName=$fileName.Split([IO.Path]::GetInvalidFileNameChars()) -join '_'
		$fileName=$fileName.Replace(":","_");
		$filePath=$Path + $fileName	
		if(Test-Path $filePath){
			Remove-Item $filePath
		}
		$jsonContent = $Object | ConvertTo-Json -Depth 16
		Add-content -Path $filePath -Value $jsonContent
	}
	Write-Debug "Finish Extract to files"
}


<#
.SYNOPSIS

Export the configuration from json response to files.

.DESCRIPTION

Export the configuration from json response to files.

.PARAMETER OutputPath

Store the files in the given folder

.OUTPUTS

No return
#>
function Export-SpConfig
{
	[CmdletBinding()]
    Param(
        [string] $OutputPath
		
    )
	process {
		if(!(Test-Path $OutputPath)){
			throw "Invalid path '$($OutputPath)' please create a directory and try again"
		}
		#$CONFIG_TYPES= @("ACCESS_REQUEST_CONFIG","ATTR_SYNC_SOURCE_CONFIG","AUTH_ORG","CAMPAIGN_FILTER","FORM_DEFINITION","IDENTITY_OBJECT_CONFIG","IDENTITY_PROFILE","LIFECYCLE_STATE","NOTIFICATION_TEMPLATE","PASSWORD_POLICY","PASSWORD_SYNC_GROUP","PUBLIC_IDENTITIES_CONFIG","SERVICE_DESK_INTEGRATION","SOD_POLICY","SOURCE","TRANSFORM","TRIGGER_SUBSCRIPTION","WORKFLOWS")
		$body = @"

{
    `"excludeTypes`": [`"RULE`",`"ACCESS_PROFILE`",`"GOVERNANCE_GROUP`"]
}
"@
		try {
				$DebugPreference = 'continue'
				$SailpointConfig=Get-DefaultConfiguration
				$token=Get-IDNAccessToken
				$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
				$headers.Add("Content-Type", "application/json")
				$headers.Add("Accept", "application/json")
				$headers.Add("Authorization", "Bearer $token")
				Write-Debug "Initiating Export $($SailpointConfig.BaseUrl)beta/sp-config/export"
				$InitExportResponse = Invoke-RestMethod "$($SailpointConfig.BaseUrl)beta/sp-config/export" -Method 'Post' -Headers $headers -body $body
				Write-Debug "Initiated Export : Response JOBID: $InitExportResponse"
				if($InitExportResponse -and $InitExportResponse.jobId){
					Write-Debug "Initiated Export done - checking is request completed for job ID $($InitExportResponse.jobId)"
					$ExportStatus = Invoke-RestMethod "$($SailpointConfig.BaseUrl)beta/sp-config/export/$($InitExportResponse.jobId)" -Method 'GET' -Headers $headers -Proxy $POWERSHELL_CONFIG.idn.proxy
					if($ExportStatus){
						Write-Debug "checking is request done"
						$count = 0;
						while ($ExportStatus.status -ne "COMPLETE")
						{
							Write-Debug "request not completed to download configurations - wait 2 seconds now - TOtal time  in seconds $count"
							$count = $count + 2;
							start-sleep -Seconds 2;
							$ExportStatus = Invoke-RestMethod "$($SailpointConfig.BaseUrl)beta/sp-config/export/$($InitExportResponse.jobId)" -Method 'GET' -Headers $headers -Proxy $POWERSHELL_CONFIG.idn.proxy
						}
						Write-Debug "REquest completed starting download $($SailpointConfig.BaseUrl)/beta/sp-config/export/$($InitExportResponse.jobId)/download"
						$ConfigResponse = Invoke-RestMethod "$($SailpointConfig.BaseUrl)/beta/sp-config/export/$($InitExportResponse.jobId)/download" -Method 'GET' -Headers $headers -Proxy $POWERSHELL_CONFIG.idn.proxy
						Write-Debug "download completed"
					}
				}else{
					Write-Debug "InitExportResponse Failed"
				}
			}catch{
				Write-Debug "Failed: $($_.exception)"
				throw $_
			}
			#To handle if not a PSCUstomObject
			If( [string]$ConfigResponse.GetType() -eq "string" ){
				Write-Debug "Invoke-Rest didnt parse into PSCustomObject, using json String"
				Export-Files ($ConfigResponse | ConvertFrom-Json -AsHashTable -Depth 100 )
			}
			else{
				Export-Files $ConfigResponse
			}
		}
}

<#
.SYNOPSIS

This command do the git pull on given $OutputPath and export the configurations to the $OutputPath

.DESCRIPTION

Export the configuration from json response to files.

.PARAMETER OutputPath

Store the files in the given folder

.OUTPUTS

No return
#>

function Export-SpConfigAndCommit{

	[CmdletBinding()]
	Param(
		[string] $OutputPath
	)
	Export-SpConfig	
	Set-Location $OutputPath
	& "$PSScriptRoot\commandLine\git-action.bat" pull 
	Export-Files $ConfigResponse
	& "$PSScriptRoot\commandLine\git-action.bat" add 
	& "$PSScriptRoot\commandLine\git-action.bat" commit sync
	& "$PSScriptRoot\commandLine\git-action.bat" push
}


